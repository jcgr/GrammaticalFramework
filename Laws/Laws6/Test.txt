gf
e
i LawsLin.gf LawsEng.gf LawsDan.gf

GF:count/1: 
Pi C : candidate . Pi H : nat . Pi L : list . Pi N : nat . Pi Q : nat . Pi S : nat . Pi U : nat . count-ballots S H ( s ! U ) * uncounted-ballot C L * hopeful C N * !quota Q * !nat-less ( s ! N ) Q -o { counted-ballot C L * hopeful C ( s ! N ) * count-ballots S H U }

GF:count/2:
Pi C : candidate . Pi H : nat . Pi L : list . Pi N : nat . Pi Q : nat . Pi S : nat . Pi U : nat . Pi W : list . count-ballots ( s ! ( s ! S ) ) ( s ! H ) ( s ! U ) * uncounted-ballot C L * hopeful C N * !quota Q * !nat-lesseq Q ( s ! N ) * winners W -o { counted-ballot C L * !elected C * winners ( cons ! C ! W ) * count-ballots ( s ! S ) H U }

Laws: Formular (_Lolli (_Conj (_MPos (_Unit (_Pi (_Arg Arg_C))) (_MPos (_Unit (_Pi (_Arg Arg_H))) (_MPos (_Unit (_Pi (_Arg Arg_L))) (_MPos (_Unit (_Pi (_Arg Arg_N))) (_MPos (_Unit (_Pi (_Arg Arg_Q))) (_MPos (_MPos (_Unit (_Pi (_Arg Arg_S))) (_Unit (_Pi (_Arg Arg_U)))) (_MPos (_Unit (_Pi (_Arg Arg_W))) (_Atom (Atom_Ident (Ident_Tally ?34 ?35 (_ArgMinus (_ArgMinus (_Arg Arg_S))) (_ArgMinus (_Arg Arg_H)) (_ArgMinus (_Arg Arg_U)) ?46 ?47 ?48 ?49)))))))))) _Conj2 (_Conj (_Conj (_Atom (Atom_Ident (Ident_Uncounted (_Arg Arg_C) ?63 ?64 ?65 ?66 ?67 (_Arg Arg_L) ?70 ?71))) _Conj2 (_Conj (_Atom (Atom_Ident (Ident_Hopeful (_Arg Arg_C) (_Arg Arg_N) ?80 ?81 ?82 ?83 ?84 ?85 ?86))) _Conj2 (_Conj (_Atom (Atom_Ident (Ident_Quota ?91 ?92 ?93 ?94 ?95 (_Arg Arg_Q) ?98 ?99 ?100))) _Conj2 (_Atom (Atom_Math (_FinalFormula (_Math (_Arg Arg_Q)) LessEqual (_Math (_ArgMinus (_Arg Arg_N))))))))) _Conj2 (_Atom (Atom_Ident (Ident_Winners ?120 ?121 ?122 ?123 ?124 ?125 ?126 ?127 (_Arg Arg_W)))))) _Lolli2 (_Mon (_Conj (_Atom (Atom_Ident (Ident_Counted (_Arg Arg_C) ?138 ?139 ?140 ?141 ?142 (_Arg Arg_L) ?145 ?146))) _Conj2 (_Conj (_Conj (_Atom (Atom_Ident (Ident_Elected (_Arg Arg_C) ?153 ?154 ?155 ?156 ?157 ?158 ?159 ?160))) _Conj2 (_Atom (Atom_Ident (Ident_Winners ?165 ?166 ?167 ?168 ?169 ?170 ?171 ?172 (_ArgList (_Arg Arg_C) (_Arg Arg_W)))))) _Conj2 (_Atom (Atom_Ident (Ident_Tally ?183 ?184 (_ArgMinus (_Arg Arg_S)) (_Arg Arg_H) (_Arg Arg_U) ?192 ?193 ?194 ?195)))))))
LawsEng: if [ we are tallying votes and there is a set of seats (S) minus 1 minus 1 open, a set of hopeful candidates (H) minus 1 , and a set of uncounted ballots (U) minus 1 cast ] and [ there is an uncounted ballot with highest preference for a certain candidate (C) with a list (L) lower preferences ] and [ there is a hopeful candidate (C) with a set of counted ballots (N) ] and [ a set of votes (Q) are needed to be elected ] and [ the amount of a set of votes (Q) is less than or equal to the amount of a set of counted ballots (N) minus 1 ] and [ the candidates in a list of winners (W) have been elected thus far ] then { [ there is a counted ballot with highest preference for a certain candidate (C) with a list (L) lower preferences ] and [ candidate (C) has been (and will remain) elected ] and [ the candidates in list containing candidate (C) and a list of winners (W) have been elected thus far ] and [ we are tallying votes and there is a set of seats (S) minus 1 open, a set of hopeful candidates (H) , and a set of uncounted ballots (U) cast ] }
LawsLin: Pi C : nat . Pi H : nat . Pi L : nat . Pi N : nat . Pi Q : nat . Pi S : nat . Pi U : nat . Pi W : nat . tally-votes ( s ! ( s ! S ) ) ( s ! H ) ( s ! U ) * uncounted-ballot C L * hopeful C N * !quota Q * !nat-lesseq Q ( s ! N ) * winners W -o { counted-ballot C L * !elected C * winners ( cons ! C ! W ) * tally-votes ( s ! S ) H U }

GF:count/3: 
Pi C : candidate . Pi H : nat . Pi L : list . Pi N : nat . Pi Q : nat . Pi U : nat . Pi W : list . count-ballots ( s ! z ) H U * uncounted-ballot C L * hopeful C N * !quota Q * !nat-lesseq Q ( s ! N ) * winners W -o { counted-ballot C L * !elected C * winners ( cons ! C ! W ) * !defeat-all }

GF:count/4_1: 
Pi C : candidate . Pi C' : candidate . Pi H : nat . Pi L : list . Pi S : nat . Pi U : nat . count-ballots S H U * uncounted-ballot C ( cons ! C' ! L ) * !elected C -o { uncounted-ballot C' L * count-ballots S H U }

GF:count/4_2: 
Pi C : candidate . Pi C' : candidate . Pi H : nat . Pi L : list . Pi S : nat . Pi U : nat . count-ballots S H U * uncounted-ballot C ( cons ! C' ! L ) * !defeated C -o { uncounted-ballot C' L * count-ballots S H U }

GF:count/5_1: 
Pi C : candidate . Pi H : nat . Pi S : nat . Pi U : nat . count-ballots S H ( s ! U ) * uncounted-ballot C nil * !elected C -o { count-ballots S H U }

GF:count/5_2: 
Pi C : candidate . Pi H : nat . Pi S : nat . Pi U : nat . count-ballots S H ( s ! U ) * uncounted-ballot C nil * !defeated C -o { count-ballots S H U }

GF:count/6: 
Pi H : nat . Pi S : nat . count-ballots S H z -o { defeat-min S H z }

GF:defeat-min/1: 
Pi C : candidate . Pi H : nat . Pi M : nat . Pi N : nat . Pi S : nat . defeat-min S ( s ! H ) M * hopeful C N -o { minimum C N * defeat-min S H ( s ! M ) }

GF:defeat-min/2: 
Pi M : nat . Pi S : nat . defeat-min S z M -o { defeat-min' S z M }

GF:defeat-min'/1: 
Pi C : candidate . Pi C' : candidate . Pi H : nat . Pi M : nat . Pi N : nat . Pi N' : nat . Pi S : nat . defeat-min' S H ( s ! M ) * minimum C N * minimum C' N' * !nat-less N N' -o { minimum C N * hopeful C' N' * defeat-min' S ( s ! H ) M }

GF:defeat-min'/2: 
Pi C : candidate . Pi H : nat . Pi N : nat . Pi S : nat . defeat-min' S H ( s ! z ) * minimum C N -o { !defeated C * transfer C N S H z }

GF:transfer/1: 
Pi C : candidate . Pi C' : candidate . Pi H : nat . Pi L : list . Pi N : nat . Pi S : nat . Pi U : nat . transfer C ( s ! N ) S H U * counted-ballot C ( cons ! C' ! L ) -o { uncounted-ballot C' L * transfer C N S H ( s ! U ) }

GF:transfer/2:
Pi C : candidate . Pi H : nat . Pi N : nat . Pi S : nat . Pi U : nat . transfer C ( s ! N ) S H U * counted-ballot C nil -o {  transfer C N S H U  }

GF:transfer/3: 
Pi C : candidate . Pi H : nat . Pi S : nat . Pi U : nat . transfer C z S H U * !nat-less S H -o { count-ballots S H U }

GF:transfer/4: 
Pi C : candidate . Pi H : nat . Pi S : nat . Pi U : nat . transfer C z S H U * !nat-lesseq H S -o { !elect-all }

GF:defeat-all/1: 
Pi C : candidate . Pi N : nat . !defeat-all * hopeful C N -o { !defeated C }

GF:elect-all/1: 
Pi C : candidate . Pi N : nat . Pi W : list . !elect-all * hopeful C N * winners W -o { !elected C * winners ( cons ! C ! W ) }

GF:cleanup/1: 
Pi C : candidate . Pi L : list . !defeat-all * uncounted-ballot C L -o { 1 }

GF:cleanup/2: 
Pi C : candidate . Pi L : list . !defeat-all * counted-ballot C L -o { 1 }

GF:cleanup/3: 
Pi C : candidate . Pi L : list . !elect-all * uncounted-ballot C L -o { 1 }

GF:cleanup/4: 
Pi C : candidate . Pi L : list . !elect-all * counted-ballot C L -o { 1 }

GF:run/1: 
Pi H : nat . Pi Q : nat . Pi S : nat . Pi U : nat . Pi xx3: nat . run S H U * !nat-divmod U ( s ! S ) Q xx3 -o { !quota ( s ! Q ) * winners nil * count-ballots S H U }
